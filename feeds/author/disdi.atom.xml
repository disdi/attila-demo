<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Libre Car - disdi</title><link href="https://librecar.dev/" rel="alternate"></link><link href="https://librecar.dev/feeds/author/disdi.atom.xml" rel="self"></link><id>https://librecar.dev/</id><updated>2024-04-30T11:18:41+02:00</updated><subtitle>Libre Car Control</subtitle><entry><title>Milestone 5 Update</title><link href="https://librecar.dev/2024/04/milestone-five-update/" rel="alternate"></link><published>2024-04-25T01:25:00+02:00</published><updated>2024-04-30T11:18:35+02:00</updated><author><name>disdi</name></author><id>tag:librecar.dev,2024-04-25:/2024/04/milestone-five-update/</id><summary type="html">&lt;div class="section" id="automotive-protocols-on-litex"&gt;
&lt;h2&gt;Automotive Protocols on Litex&lt;/h2&gt;
&lt;div class="section" id="universal-measurement-and-calibration-protocol"&gt;
&lt;h3&gt;Universal Measurement and Calibration Protocol&lt;/h3&gt;
&lt;p&gt;The CAN Calibration Protocol (CCP) is an interface that enables read/write access to an Electronic Control Unit (ECU).
It enables calibration, data measurement, flashing and more.&lt;/p&gt;
&lt;p&gt;The Universal Measurement and Calibration Protocol (XCP) is the successor to CCP with various …&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;</summary><content type="html">&lt;div class="section" id="automotive-protocols-on-litex"&gt;
&lt;h2&gt;Automotive Protocols on Litex&lt;/h2&gt;
&lt;div class="section" id="universal-measurement-and-calibration-protocol"&gt;
&lt;h3&gt;Universal Measurement and Calibration Protocol&lt;/h3&gt;
&lt;p&gt;The CAN Calibration Protocol (CCP) is an interface that enables read/write access to an Electronic Control Unit (ECU).
It enables calibration, data measurement, flashing and more.&lt;/p&gt;
&lt;p&gt;The Universal Measurement and Calibration Protocol (XCP) is the successor to CCP with various improvements including
support for more transport layers such as Ethernet, FlexRay and SxL.&lt;/p&gt;
&lt;p&gt;XCP provides direct access to the inner workings of an ECU. This lets you request high-frequency parameter data that may
otherwise only be known to the ECU. Further, it also lets you modify the ECU algorithms and variables, making it easy to
test and calibrate ECUs.&lt;/p&gt;
&lt;p&gt;The CCP/XCP protocol is based on a single-master/multi-slave concept. An external measurement &amp;amp; calibration tool
(e.g. a PC/device/data logger) serves as the master and is able to read/write from one or more ECUs aka slaves.&lt;/p&gt;
&lt;p&gt;Opensource implementation of XCP is available at :
&lt;a class="reference external" href="https://github.com/vectorgrp/XCPlite"&gt;https://github.com/vectorgrp/XCPlite&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;To enable basic XCP on Litex, a small demo implementation is mirrored at :
&lt;a class="reference external" href="https://github.com/disdi/XCPlite"&gt;https://github.com/disdi/XCPlite&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;As part of this milestone this is now integrated in buildroot :
&lt;a class="reference external" href="https://gitlab.com/saket.sinha89/buildroot/-/commit/e75a1e270292d99e62bd656b3f162dc79caadac8"&gt;https://gitlab.com/saket.sinha89/buildroot/-/commit/e75a1e270292d99e62bd656b3f162dc79caadac8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The below image shows the demo working with creating a dummy XCP Server which talks to XCP slave on Litex over localhost
via UDP to measure variables at fixed memory address.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external image-reference" href="/assets/images/xcplite-demo.png"&gt;&lt;img alt="Image" src="/assets/images/xcplite-demo.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="Nlnet"></category><category term="Nlnet"></category></entry><entry><title>Milestone 5</title><link href="https://librecar.dev/2024/04/milestone-five/" rel="alternate"></link><published>2024-04-24T01:25:00+02:00</published><updated>2024-04-30T11:18:41+02:00</updated><author><name>disdi</name></author><id>tag:librecar.dev,2024-04-24:/2024/04/milestone-five/</id><summary type="html">&lt;div class="section" id="automotive-protocols-on-litex"&gt;
&lt;h2&gt;Automotive Protocols on Litex&lt;/h2&gt;
&lt;div class="section" id="unified-diagnostic-services"&gt;
&lt;h3&gt;Unified Diagnostic Services&lt;/h3&gt;
&lt;p&gt;Unified Diagnostic Services (UDS) is a communication protocol used in automotive Electronic Control Units (ECUs) to
enable diagnostics, firmware updates, routine testing and more.&lt;/p&gt;
&lt;p&gt;UDS communication is performed in a client-server relationship -&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;client being a tester-tool&lt;/li&gt;
&lt;li&gt;server being a vehicle ECU&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The UDS …&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;</summary><content type="html">&lt;div class="section" id="automotive-protocols-on-litex"&gt;
&lt;h2&gt;Automotive Protocols on Litex&lt;/h2&gt;
&lt;div class="section" id="unified-diagnostic-services"&gt;
&lt;h3&gt;Unified Diagnostic Services&lt;/h3&gt;
&lt;p&gt;Unified Diagnostic Services (UDS) is a communication protocol used in automotive Electronic Control Units (ECUs) to
enable diagnostics, firmware updates, routine testing and more.&lt;/p&gt;
&lt;p&gt;UDS communication is performed in a client-server relationship -&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;client being a tester-tool&lt;/li&gt;
&lt;li&gt;server being a vehicle ECU&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The UDS protocol (ISO 14229) is supported on both  CAN and Ethernet.It describes the application layer requirements for
UDS (independent of what lower layer protocol is used).
Opensource implementation on CAN is available at:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://pypi.org/project/udsoncan/"&gt;https://pypi.org/project/udsoncan/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The standard which specifies a transport protocol and network layer services for use in CAN based vehicle networks is
CAN ISO-TP - Transport Protocol (ISO 15765).
Opensource implementation is available at:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://pypi.org/project/can-isotp/"&gt;https://pypi.org/project/can-isotp/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;DoIP(Diagnostics over Internet Protocol) is a standardized diagnostic transport protocol according to ISO 13400.
It encapsulates diagnostics messages of protocol standards like Unified Diagnostic Services (UDS) over Ethernet.
Opensource implementation is available at:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://pypi.org/project/doipclient/"&gt;https://pypi.org/project/doipclient/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;As part of this milestone, integration of the above Opensource projects to buildroot is compelted so that it is available on Linux on Litex.
The link to the integration effort in buildroot project is available at below link -&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://gitlab.com/saket.sinha89/buildroot"&gt;https://gitlab.com/saket.sinha89/buildroot&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Once these python packages are added to buildroot project, the buildroot configuration can be updated with below options:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external image-reference" href="/assets/images/uds-config.png"&gt;&lt;img alt="Image1" src="/assets/images/uds-config.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The screenshoot below shows these packages working on buildroot rootfs of Litex Console:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external image-reference" href="/assets/images/uds-buildroot."&gt;&lt;img alt="Image" src="/assets/images/uds-buildroot.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="Nlnet"></category><category term="Nlnet"></category></entry><entry><title>Milestone 4 Complete</title><link href="https://librecar.dev/2024/04/milestone-four-complete/" rel="alternate"></link><published>2024-04-04T14:21:00+02:00</published><updated>2024-04-04T12:13:21+02:00</updated><author><name>disdi</name></author><id>tag:librecar.dev,2024-04-04:/2024/04/milestone-four-complete/</id><summary type="html">&lt;div class="section" id="bringing-up-ethernet-interface-on-litex"&gt;
&lt;h2&gt;Bringing up Ethernet interface on Litex&lt;/h2&gt;
&lt;p&gt;Support for CTUCAN interfaces has been extended from Arty to below FPGA boards :&lt;/p&gt;
&lt;p&gt;Genesys2 : &lt;a class="reference external" href="https://digilent.com/reference/programmable-logic/genesys-2/"&gt;https://digilent.com/reference/programmable-logic/genesys-2/&lt;/a&gt;
commit : &lt;a class="reference external" href="https://github.com/litex-hub/linux-on-litex-vexriscv/pull/378/commits/4e2d1bc537c68c8ab7b63ab31b31a27257dd8a23"&gt;https://github.com/litex-hub/linux-on-litex-vexriscv/pull/378/commits/4e2d1bc537c68c8ab7b63ab31b31a27257dd8a23&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Nexys A7 : &lt;a class="reference external" href="https://digilent.com/reference/programmable-logic/nexys-a7/"&gt;https://digilent.com/reference/programmable-logic/nexys-a7/&lt;/a&gt;
commit : &lt;a class="reference external" href="https://github.com/litex-hub/linux-on-litex-vexriscv/pull/378/commits/975064cddb70a86cf43d26888ccb749caaf26be8"&gt;https://github.com/litex-hub/linux-on-litex-vexriscv …&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;div class="section" id="bringing-up-ethernet-interface-on-litex"&gt;
&lt;h2&gt;Bringing up Ethernet interface on Litex&lt;/h2&gt;
&lt;p&gt;Support for CTUCAN interfaces has been extended from Arty to below FPGA boards :&lt;/p&gt;
&lt;p&gt;Genesys2 : &lt;a class="reference external" href="https://digilent.com/reference/programmable-logic/genesys-2/"&gt;https://digilent.com/reference/programmable-logic/genesys-2/&lt;/a&gt;
commit : &lt;a class="reference external" href="https://github.com/litex-hub/linux-on-litex-vexriscv/pull/378/commits/4e2d1bc537c68c8ab7b63ab31b31a27257dd8a23"&gt;https://github.com/litex-hub/linux-on-litex-vexriscv/pull/378/commits/4e2d1bc537c68c8ab7b63ab31b31a27257dd8a23&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Nexys A7 : &lt;a class="reference external" href="https://digilent.com/reference/programmable-logic/nexys-a7/"&gt;https://digilent.com/reference/programmable-logic/nexys-a7/&lt;/a&gt;
commit : &lt;a class="reference external" href="https://github.com/litex-hub/linux-on-litex-vexriscv/pull/378/commits/975064cddb70a86cf43d26888ccb749caaf26be8"&gt;https://github.com/litex-hub/linux-on-litex-vexriscv/pull/378/commits/975064cddb70a86cf43d26888ccb749caaf26be8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;All the above boards have &amp;quot;ethernet&amp;quot; available in litex project by default so bitstream need not be modified.&lt;/p&gt;
&lt;p&gt;I added support in litex buildroot configuration file to support bringing up network interface via DHCP.&lt;/p&gt;
&lt;p&gt;commit : &lt;a class="reference external" href="https://github.com/litex-hub/linux-on-litex-vexriscv/pull/378/commits/241ffa8e6a4b3069e7a3f16b9d586160af55d406"&gt;https://github.com/litex-hub/linux-on-litex-vexriscv/pull/378/commits/241ffa8e6a4b3069e7a3f16b9d586160af55d406&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;As a result in Litex rootfs, buildroot generated /etc/network/interfaces with dhcp enabled for eth0 as shown below :&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external image-reference" href="/assets/images/eth-fpga.png"&gt;&lt;img alt="Image1" src="/assets/images/eth-fpga.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="bringing-up-cannelloni-on-litex"&gt;
&lt;h2&gt;Bringing up Cannelloni on Litex&lt;/h2&gt;
&lt;p&gt;Cannelloni uses UDP, TCP or SCTP to transfer CAN frames between two machines not connected via CAN bus.&lt;/p&gt;
&lt;p&gt;Repository: &lt;a class="reference external" href="https://github.com/mguentner/cannelloni"&gt;https://github.com/mguentner/cannelloni&lt;/a&gt;&lt;/p&gt;
&lt;div class="section" id="cannelloni-on-rpi"&gt;
&lt;h3&gt;Cannelloni on RPI&lt;/h3&gt;
&lt;p&gt;We use Raspberry-Pi(RPI) to test cannelloni packet exchange with Litex as shown below :&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external image-reference" href="/assets/images/cannelloni-rpi.png"&gt;&lt;img alt="Image2" src="/assets/images/cannelloni-rpi.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The above image shows RPI using a virtual CAN interface and starting cannelloni with Litex IP as remote.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="cannelloni-on-litex"&gt;
&lt;h3&gt;Cannelloni on Litex&lt;/h3&gt;
&lt;p&gt;Cannelloni is already supported in buildroot.
I added support in litex buildroot configuration file to support cannelloni on Litex.&lt;/p&gt;
&lt;p&gt;commit : &lt;a class="reference external" href="https://github.com/litex-hub/linux-on-litex-vexriscv/pull/378/commits/6a7676b3ef6d7b3c4a9c905e9fba3d0beddb69e8"&gt;https://github.com/litex-hub/linux-on-litex-vexriscv/pull/378/commits/6a7676b3ef6d7b3c4a9c905e9fba3d0beddb69e8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;As a result in Litex rootfs, cannelloni package is installed as shown below :&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external image-reference" href="/assets/images/cannelloni-fpga.png"&gt;&lt;img alt="Image3" src="/assets/images/cannelloni-fpga.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The above image shows Litex using CTUCAN interface and starting cannelloni with RPI IP as remote.
We then use can-utils(cansend and candump) to send/receive CAN packets over UDP.&lt;/p&gt;
&lt;p&gt;All commits are part of the Pull request to Linux on Litex Project :
&lt;a class="reference external" href="https://github.com/litex-hub/linux-on-litex-vexriscv/pull/378"&gt;https://github.com/litex-hub/linux-on-litex-vexriscv/pull/378&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="Nlnet"></category><category term="Nlnet"></category></entry><entry><title>Milestone 3 Complete</title><link href="https://librecar.dev/2024/03/milestone-three-complete/" rel="alternate"></link><published>2024-03-17T14:21:00+01:00</published><updated>2024-03-17T15:24:53+01:00</updated><author><name>disdi</name></author><id>tag:librecar.dev,2024-03-17:/2024/03/milestone-three-complete/</id><summary type="html">&lt;div class="section" id="controlling-bldc-motor-for-vehicle-with-ctucan"&gt;
&lt;h2&gt;Controlling BLDC Motor for Vehicle with CTUCAN&lt;/h2&gt;
&lt;p&gt;This is to update on completion of Milestone 3 of the project which involved controlling a motor on the CAN network with CTUCAN device.
We would need to have a motor contoller to interface with our CAN bus and control the motor.&lt;/p&gt;
&lt;p&gt;The …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;div class="section" id="controlling-bldc-motor-for-vehicle-with-ctucan"&gt;
&lt;h2&gt;Controlling BLDC Motor for Vehicle with CTUCAN&lt;/h2&gt;
&lt;p&gt;This is to update on completion of Milestone 3 of the project which involved controlling a motor on the CAN network with CTUCAN device.
We would need to have a motor contoller to interface with our CAN bus and control the motor.&lt;/p&gt;
&lt;p&gt;The ODrive is a motor control board based on the STM32 microcontroller.
It can  be used with BLDC motors (brushless DC motors), over a CAN bus to set acceleration, braking, and other parameters
for motor control systems.&lt;/p&gt;
&lt;p&gt;Hardware for ODrive is available for sale on online shop:
&lt;a class="reference external" href="https://odriverobotics.com/shop"&gt;https://odriverobotics.com/shop&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The entire firware and GUI software to interface with Odrive is available on GitHub:
&lt;a class="reference external" href="https://github.com/odriverobotics/ODrive/"&gt;https://github.com/odriverobotics/ODrive/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external image-reference" href="/assets/images/s1.jpg"&gt;&lt;img alt="Image8" src="/assets/images/s1.jpg" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class="section" id="hardware-requirements"&gt;
&lt;h3&gt;Hardware Requirements&lt;/h3&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;A brushless motor.&lt;/li&gt;
&lt;li&gt;Odrive S1&lt;/li&gt;
&lt;li&gt;FPGA device with CAN controller/transceiver&lt;/li&gt;
&lt;li&gt;A &amp;gt;12V power supply or battery.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="hardware-connections"&gt;
&lt;h3&gt;Hardware Connections&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Connect screw terminals representing the motor phases to A/B/C of Odrive S1 Power Pads.&lt;/li&gt;
&lt;li&gt;Connect the power supply cables to Odrive S1 solder pads that are labelled +/- and Arty A7 board&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Since CAN bus is not isolated, use power supply to power both. To run Arty A7 board with same DC source, below accesories can be used :&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;DC-DC convertor : &lt;a class="reference external" href="https://amzn.eu/d/iUmVObb"&gt;https://amzn.eu/d/iUmVObb&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a class="reference external image-reference" href="/assets/images/dc-dc.png"&gt;&lt;img alt="Image" src="/assets/images/dc-dc.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;DC Hollow Connector :  &lt;a class="reference external" href="https://amzn.eu/d/gej5q8E"&gt;https://amzn.eu/d/gej5q8E&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a class="reference external image-reference" href="/assets/images/dc-connector.jpg"&gt;&lt;img alt="Image1" src="/assets/images/dc-connector.jpg" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Connect Odrive S1 with FPGA board over CAN bus.&lt;/li&gt;
&lt;li&gt;Connect motor to Odrive S1 via 3 phase wire.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Complete setup can be illustrated in below daigram&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external image-reference" href="/assets/images/setup.png"&gt;&lt;img alt="Image6" src="/assets/images/setup.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In reality, it resemebles like seen in below image:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external image-reference" href="/assets/images/whole-setup.jpeg"&gt;&lt;img alt="Image2" src="/assets/images/whole-setup.jpeg" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="controlling-motor-controller-with-can-bus"&gt;
&lt;h3&gt;Controlling Motor Controller with CAN bus&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Power up Arty board with CTUCAN driver enabled&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a class="reference external image-reference" href="/assets/images/ctucan-net.png"&gt;&lt;img alt="Image4" src="/assets/images/ctucan-net.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Use GUI Wizard of Odrive to calibrate the motor.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a class="reference external image-reference" href="/assets/images/calibrate.png"&gt;&lt;img alt="Image3" src="/assets/images/calibrate.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Check if any data is recevied on CAN bus with &lt;cite&gt;candump&lt;/cite&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a class="reference external image-reference" href="/assets/images/candump.png"&gt;&lt;img alt="Image7" src="/assets/images/candump.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;To make sense of this data we would use CAN Simple protocol provided by Odrive.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/odriverobotics/ODriveResources/blob/master/examples/can_simple.py"&gt;https://github.com/odriverobotics/ODriveResources/blob/master/examples/can_simple.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Motor should start rotating with torque of 1 turns per second.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external image-reference" href="/assets/images/can-simple.png"&gt;&lt;img alt="Image5" src="/assets/images/can-simple.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="Nlnet"></category><category term="Nlnet"></category></entry><entry><title>Documentation</title><link href="https://librecar.dev/2024/01/Documentation/" rel="alternate"></link><published>2024-01-07T21:43:12+02:00</published><updated>2024-01-07T09:05:24+01:00</updated><author><name>disdi</name></author><id>tag:librecar.dev,2024-01-07:/2024/01/Documentation/</id><content type="html">&lt;p&gt;Documentation to build and test CAN bus with Litex has been added to Wiki section of this website.
Direct link can be found at : &lt;a class="reference external" href="https://disdi.github.io/librecar-wiki/"&gt;https://disdi.github.io/librecar-wiki/&lt;/a&gt; .&lt;/p&gt;
</content><category term="Nlnet"></category><category term="Nlnet"></category></entry><entry><title>Milestone 2 Complete</title><link href="https://librecar.dev/2023/12/milestone-two-complete/" rel="alternate"></link><published>2023-12-16T14:21:00+01:00</published><updated>2023-12-16T13:06:38+01:00</updated><author><name>disdi</name></author><id>tag:librecar.dev,2023-12-16:/2023/12/milestone-two-complete/</id><summary type="html">&lt;p&gt;This is to update on completion of Milestone 2 of the project which involved communication on the CAN network with real CAN devices.&lt;/p&gt;
&lt;p&gt;The major work done in this Milestone involved :&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;Bring UP the CTUCAN device enumerated in first Milestone.
Update of Litex interfaces was needed to make CAN interface …&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;p&gt;This is to update on completion of Milestone 2 of the project which involved communication on the CAN network with real CAN devices.&lt;/p&gt;
&lt;p&gt;The major work done in this Milestone involved :&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;Bring UP the CTUCAN device enumerated in first Milestone.
Update of Litex interfaces was needed to make CAN interface UP and running.&lt;/p&gt;
&lt;p&gt;Refer : &lt;a class="reference external" href="https://github.com/disdi/linux-on-litex-vexriscv/commit/b4c7c81e48d285977055b19cb08069af642ff516"&gt;https://github.com/disdi/linux-on-litex-vexriscv/commit/b4c7c81e48d285977055b19cb08069af642ff516&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Use ip utilites of linux which treats CAN as network device and make it up.
Support was added to buildroot to include needed utilities for CAN and make it part of bootup script.&lt;/p&gt;
&lt;p&gt;Refer : &lt;a class="reference external" href="https://github.com/disdi/linux-on-litex-vexriscv/commit/64ecd04d2eefc14753181dbf8a1bc65d09c65991"&gt;https://github.com/disdi/linux-on-litex-vexriscv/commit/64ecd04d2eefc14753181dbf8a1bc65d09c65991&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Below image shows CAN bus coming up on system restart and can-utils is used for communication over CAN network :&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external image-reference" href="/assets/images/litex-can.png"&gt;&lt;img alt="Image" src="/assets/images/litex-can.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Now when CAN IP is up, we needed a CAN transceiver to connect to CAN network. SN65HVD230 CAN Board is used for this purpose.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external image-reference" href="/assets/images/SN65HVD230-CAN-Board-2.jpg"&gt;&lt;img alt="Image6" src="/assets/images/SN65HVD230-CAN-Board-2.jpg" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Refer : &lt;a class="reference external" href="https://www.waveshare.com/sn65hvd230-can-board.htm"&gt;https://www.waveshare.com/sn65hvd230-can-board.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;can_tx and canrx are are mapped to ck_io pins exposed on J4 of Arty Board.
&lt;a class="reference external" href="https://github.com/disdi/linux-on-litex-vexriscv/blob/master/soc_linux.py#L34"&gt;https://github.com/disdi/linux-on-litex-vexriscv/blob/master/soc_linux.py#L34&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;They are connected to CAN RX and CAN TX of transceiver with 3.3V to power it. Connection between FPGA board and CAN transceiver is shown below :&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external image-reference" href="/assets/images/fpga-traceiver.jpeg"&gt;&lt;img alt="Image2" src="/assets/images/fpga-traceiver.jpeg" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Considerable testing is done over different CAN devices to confirm CTUCAN IP is able to comunicate over CAN network.
PCAN-USB adapter is used to emulate CAN device over development computer.&lt;/p&gt;
&lt;p&gt;Refer : &lt;a class="reference external" href="https://www.peak-system.com/PCAN-USB.199.0.html?&amp;amp;L=1"&gt;https://www.peak-system.com/PCAN-USB.199.0.html?&amp;amp;L=1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Connection between PCAN-USB adapter with DB9 connector and CAN transceiver is shown below :&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external image-reference" href="/assets/images/tranciever-Pcanusb.jpeg"&gt;&lt;img alt="Image3" src="/assets/images/tranciever-Pcanusb.jpeg" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CANH and CANL of transceiver is attached to (pin2 and pin7) DB9 connector. For DB9 Connector pinout for CAN, refer : &lt;a class="reference external" href="https://documentation.help/NI-CAN/High-Speed_CAN_Pinout_Cable.html"&gt;https://documentation.help/NI-CAN/High-Speed_CAN_Pinout_Cable.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;PCAN-View software run on development computer is to analyze the CAN network to check for the protocal conformity and errors.&lt;/p&gt;
&lt;p&gt;Refer : &lt;a class="reference external" href="https://www.peak-system.com/PCAN-View.242.0.html?&amp;amp;L=1"&gt;https://www.peak-system.com/PCAN-View.242.0.html?&amp;amp;L=1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external image-reference" href="/assets/images/pcan-trace.jpeg"&gt;&lt;img alt="Image4" src="/assets/images/pcan-trace.jpeg" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="section" id="testbench-setup"&gt;
&lt;h2&gt;TestBench Setup&lt;/h2&gt;
&lt;blockquote&gt;
&lt;a class="reference external image-reference" href="/assets/images/can_testbench.png"&gt;&lt;img alt="Image5" src="/assets/images/can_testbench.png" /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;The testbench results can be seen by referencing Section 2 where 01010101 sent from Litex Console is recieved in PCAN-View In Section 5.&lt;/p&gt;
&lt;/div&gt;
</content><category term="Nlnet"></category><category term="Nlnet"></category></entry><entry><title>Milestone 1 Complete</title><link href="https://librecar.dev/2023/06/milestone-one-complete/" rel="alternate"></link><published>2023-06-08T14:21:00+02:00</published><updated>2023-06-24T04:54:35+02:00</updated><author><name>disdi</name></author><id>tag:librecar.dev,2023-06-08:/2023/06/milestone-one-complete/</id><summary type="html">&lt;div class="section" id="ctucan-controller-for-linux"&gt;
&lt;h2&gt;CTUCAN Controller for Linux&lt;/h2&gt;
&lt;p&gt;We updated linux-on-litex kernel config to enable CTUCAN linux driver.&lt;/p&gt;
&lt;p&gt;The screenshoot below shows the menuconfig to enable CTUCAN driver:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external image-reference" href="/assets/images/ctucan-config.png"&gt;&lt;img alt="Image" src="/assets/images/ctucan-config.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Next we had to update the device tree manually to add a section for CTUCAN driver:&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;CTU_CAN_FD_0: &lt;a class="reference external" href="mailto:CTU_CAN_FD&amp;#64;80010000"&gt;CTU_CAN_FD&amp;#64;80010000&lt;/a&gt; {&lt;/dt&gt;
&lt;dd&gt;compatible = &amp;quot;ctu,ctucanfd&amp;quot;;
reg = &amp;lt;0x80010000 0x10000&amp;gt;;
interrupt-parent …&lt;/dd&gt;&lt;/dl&gt;&lt;/div&gt;</summary><content type="html">&lt;div class="section" id="ctucan-controller-for-linux"&gt;
&lt;h2&gt;CTUCAN Controller for Linux&lt;/h2&gt;
&lt;p&gt;We updated linux-on-litex kernel config to enable CTUCAN linux driver.&lt;/p&gt;
&lt;p&gt;The screenshoot below shows the menuconfig to enable CTUCAN driver:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external image-reference" href="/assets/images/ctucan-config.png"&gt;&lt;img alt="Image" src="/assets/images/ctucan-config.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Next we had to update the device tree manually to add a section for CTUCAN driver:&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;CTU_CAN_FD_0: &lt;a class="reference external" href="mailto:CTU_CAN_FD&amp;#64;80010000"&gt;CTU_CAN_FD&amp;#64;80010000&lt;/a&gt; {&lt;/dt&gt;
&lt;dd&gt;compatible = &amp;quot;ctu,ctucanfd&amp;quot;;
reg = &amp;lt;0x80010000 0x10000&amp;gt;;
interrupt-parent = &amp;lt;&amp;amp;intc0&amp;gt;;
interrupts = &amp;lt;0 30 4&amp;gt;;
clocks = &amp;lt;&amp;amp;sys_clk&amp;gt;;
status = &amp;quot;okay&amp;quot;;
};&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;The link to the complete modified device-tree is available at below link -
&lt;a class="reference external" href="https://github.com/disdi/linux-on-litex-vexriscv/commit/64970aea0ce4dfb10d16ffeece8837b032a702d4"&gt;https://github.com/disdi/linux-on-litex-vexriscv/commit/64970aea0ce4dfb10d16ffeece8837b032a702d4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;When Linux  boots up, it shows the CTUCAN linux driver getting initialized.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external image-reference" href="/assets/images/ctucan-linux-boot.png"&gt;&lt;img alt="Image2" src="/assets/images/ctucan-linux-boot.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In the buildroot Image booting up we can clearly see the CTUCAN driver module is associated with a device:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external image-reference" href="/assets/images/ctucan-buildroot.png"&gt;&lt;img alt="Image3" src="/assets/images/ctucan-buildroot.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Further, it gets enumerated as a network device:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external image-reference" href="/assets/images/ctucan-net.png"&gt;&lt;img alt="Image4" src="/assets/images/ctucan-net.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Next step is to connect Digilent Arty Board running CTUCAN IP core with an external MCP2551 CAN transceiver Board and attempt
CAN transmission to another device on this CAN Bus.&lt;/p&gt;
&lt;/div&gt;
</content><category term="Nlnet"></category><category term="Nlnet"></category></entry><entry><title>Milestone 1 Update</title><link href="https://librecar.dev/2023/05/milestine-one-update/" rel="alternate"></link><published>2023-05-30T01:25:00+02:00</published><updated>2023-06-24T04:54:41+02:00</updated><author><name>disdi</name></author><id>tag:librecar.dev,2023-05-30:/2023/05/milestine-one-update/</id><summary type="html">&lt;div class="section" id="ctucan-controller-for-linux"&gt;
&lt;h2&gt;CTUCAN Controller for Linux&lt;/h2&gt;
&lt;p&gt;We updated linux-on-litex project to integrate CTUCAN Controller booting over Linux.&lt;/p&gt;
&lt;p&gt;The link to the code is available at below link -
&lt;a class="reference external" href="https://github.com/disdi/linux-on-litex-vexriscv/commit/e9f9c6b14bca11cca2195bd61f9c5334ead3221d"&gt;https://github.com/disdi/linux-on-litex-vexriscv/commit/e9f9c6b14bca11cca2195bd61f9c5334ead3221d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;When Litex BIOS boots up, it shows all the peripherals needed to boot linux alongwith CTUCAN Controller in …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;div class="section" id="ctucan-controller-for-linux"&gt;
&lt;h2&gt;CTUCAN Controller for Linux&lt;/h2&gt;
&lt;p&gt;We updated linux-on-litex project to integrate CTUCAN Controller booting over Linux.&lt;/p&gt;
&lt;p&gt;The link to the code is available at below link -
&lt;a class="reference external" href="https://github.com/disdi/linux-on-litex-vexriscv/commit/e9f9c6b14bca11cca2195bd61f9c5334ead3221d"&gt;https://github.com/disdi/linux-on-litex-vexriscv/commit/e9f9c6b14bca11cca2195bd61f9c5334ead3221d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;When Litex BIOS boots up, it shows all the peripherals needed to boot linux alongwith CTUCAN Controller in the memory region.
The screenshoot below of Litex Console:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external image-reference" href="/assets/images/litex-linux.png"&gt;&lt;img alt="Image" src="/assets/images/litex-linux.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Next step is to modify linux kernel booting over the litex bitstream with CTUCAN Controller to enumerate a CAN device.&lt;/p&gt;
&lt;/div&gt;
</content><category term="Nlnet"></category><category term="Nlnet"></category></entry><entry><title>Milestone 1</title><link href="https://librecar.dev/2023/05/milestone-1/" rel="alternate"></link><published>2023-05-09T21:43:12+02:00</published><updated>2023-06-24T04:54:47+02:00</updated><author><name>disdi</name></author><id>tag:librecar.dev,2023-05-09:/2023/05/milestone-1/</id><summary type="html">&lt;p&gt;This is to update on the first milestone that is archeived in Libre Car Control project.&lt;/p&gt;
&lt;p&gt;FPGA board boots up Linux using linux-on-litex-vexriscv&lt;/p&gt;
&lt;h6&gt;&lt;/h6&gt;
&lt;h1&gt;Replacing ECP5 with Artix7&lt;/h1&gt;
&lt;p&gt;We switched from Lattice ECP5 to Xillinx Artix7 FPGA since we found that yosys toolchain was not able to synthesize
vhdl code. The …&lt;/p&gt;</summary><content type="html">&lt;p&gt;This is to update on the first milestone that is archeived in Libre Car Control project.&lt;/p&gt;
&lt;p&gt;FPGA board boots up Linux using linux-on-litex-vexriscv&lt;/p&gt;
&lt;h6&gt;&lt;/h6&gt;
&lt;h1&gt;Replacing ECP5 with Artix7&lt;/h1&gt;
&lt;p&gt;We switched from Lattice ECP5 to Xillinx Artix7 FPGA since we found that yosys toolchain was not able to synthesize
vhdl code. The project is now being develop on Digilent Artix7 board.
We are able to boot Linux on Artix7 from the official Litex repository since this board is officially supported.&lt;/p&gt;
&lt;h1&gt;CTUCAN Controller IP&lt;/h1&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;- CTUCAN controller Litex Integration
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We generated VHDL code for CTUCAN controller and used the CTUCAN wrapper to integrate it in Litex ecosystem. It became
available as python egg in the development environment.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;- Litex SOC with CTUCAN Controller
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We created a new Litex Core with CTUCAN controller and mapped it to the processor. When Litex BIOS boots up, CTUCAN
controller can be seen in the memory region.&lt;/p&gt;
&lt;p&gt;The link to the code is available &lt;a href="https://github.com/disdi/litex-boards/commit/82413d266bb493768ba8d74b2347e850627f6c81"&gt;here&lt;/a&gt;&lt;/p&gt;</content><category term="Nlnet"></category><category term="Nlnet"></category></entry><entry><title>Introduction</title><link href="https://librecar.dev/2023/05/introduction/" rel="alternate"></link><published>2023-05-01T21:43:12+02:00</published><updated>2024-03-17T09:40:01+01:00</updated><author><name>disdi</name></author><id>tag:librecar.dev,2023-05-01:/2023/05/introduction/</id><content type="html">&lt;p&gt;This is introductory post for the project Libre Car Control.&lt;/p&gt;
&lt;p&gt;This project is funded through the &lt;a href="https://nlnet.nl/entrust/"&gt;NGI Zero Entrust Fund&lt;/a&gt;, a fund established by &lt;a href="https://nlnet.nl/"&gt;NLnet&lt;/a&gt; with financial support from the European Commission’s &lt;a href="https://www.ngi.eu/"&gt;Next Generation Internet&lt;/a&gt; program.&lt;/p&gt;
&lt;p&gt;Learn more on the &lt;a href="https://nlnet.nl/project/LibreCarControl/"&gt;NLnet project page&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://nlnet.nl"&gt;&lt;img src="https://nlnet.nl/logo/banner.png" alt="NLnet foundation logo" width="20%" /&gt;&lt;/a&gt;
&lt;a href="https://nlnet.nl/entrust"&gt;&lt;img src="https://nlnet.nl/image/logos/NGI0_tag.svg" alt="NGI Zero Logo" width="20%" /&gt;&lt;/a&gt;&lt;/p&gt;</content><category term="Nlnet"></category><category term="Nlnet"></category></entry></feed>